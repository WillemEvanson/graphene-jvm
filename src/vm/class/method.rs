use crate::string::JavaStr;

use super::{Bytecode, ConstantIdx, ConstantPool, MethodDescriptor};

pub struct Method {
    pub(super) name: ConstantIdx,
    pub(super) descriptor: ConstantIdx,
    pub(super) parsed_descriptor: MethodDescriptor,
    pub(super) flags: MethodFlags,
    pub(super) code: Option<Code>,
}

impl Method {
    pub fn name<'a>(&self, constant_pool: &'a ConstantPool) -> &'a JavaStr {
        constant_pool.get(self.name).into_utf8()
    }

    pub fn descriptor<'a>(&self, constant_pool: &'a ConstantPool) -> &'a JavaStr {
        constant_pool.get(self.descriptor).into_utf8()
    }

    pub fn parsed_descriptor(&self) -> &MethodDescriptor {
        &self.parsed_descriptor
    }

    pub fn flags(&self) -> MethodFlags {
        self.flags
    }

    pub fn bytecode(&self) -> Option<&Code> {
        self.code.as_ref()
    }
}

impl std::fmt::Debug for Method {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Method")
            .field("name", &self.name)
            .field("descriptor", &self.parsed_descriptor)
            .field("flags", &self.flags)
            .field_with("code", |f| {
                if let Some(code) = &self.code {
                    code.fmt(f)
                } else {
                    f.write_str("None")
                }
            })
            .finish()
    }
}

#[derive(Clone, Copy, PartialEq, Eq)]
pub struct MethodFlags(u16);

impl MethodFlags {
    /// Declared public; may be accessed from outside its
    /// package.
    pub const PUBLIC: Self = Self(0x0001);
    /// Declared private; usable only within the defining
    /// class.
    pub const PRIVATE: Self = Self(0x0002);
    /// Declared protected; may be accessed within
    /// subclasses.
    pub const PROTECTED: Self = Self(0x0004);
    /// Declared static
    pub const STATIC: Self = Self(0x0008);
    /// Declared final; never directly assigned to after
    /// object construction.
    pub const FINAL: Self = Self(0x0010);
    /// Declared synchronized; invocation is wrapped by a
    /// monitor use.
    pub const SYNCHRONIZED: Self = Self(0x0020);
    /// A bridge method, generated by the compiler.
    pub const BRIDGE: Self = Self(0x0040);
    /// Declared with a variable number of arguments
    pub const VARARGS: Self = Self(0x0080);
    /// Declared native; implemented in a language other
    /// than Java.
    pub const NATIVE: Self = Self(0x0100);
    /// Declared abstract; no implementation is provided.
    pub const ABSTRACT: Self = Self(0x0400);
    /// Declared strictfp; floating-point mode is FP-strict.
    pub const STRICT: Self = Self(0x0800);
    /// Declared synthetic; not present in the source code.
    pub const SYNTHETIC: Self = Self(0x1000);

    /// Used for constructing a value during parsing. We do
    /// check bits here because unknown bits are to be
    /// ignored according to the specification.
    pub(super) const fn from_bits(bits: u16) -> Self {
        Self(bits)
    }

    const FLAGS: [(MethodFlags, &'static str); 12] = [
        (MethodFlags::PUBLIC, "PUBLIC"),
        (MethodFlags::PRIVATE, "PRIVATE"),
        (MethodFlags::PROTECTED, "PROTECTED"),
        (MethodFlags::STATIC, "STATIC"),
        (MethodFlags::FINAL, "FINAL"),
        (MethodFlags::SYNCHRONIZED, "SYNCHRONIZED"),
        (MethodFlags::BRIDGE, "BRIDGE"),
        (MethodFlags::VARARGS, "VARARGS"),
        (MethodFlags::NATIVE, "NATIVE"),
        (MethodFlags::ABSTRACT, "ABSTRACT"),
        (MethodFlags::STRICT, "STRICT"),
        (MethodFlags::SYNTHETIC, "SYNTHETIC"),
    ];
}

impl std::ops::BitAnd<MethodFlags> for MethodFlags {
    type Output = MethodFlags;

    fn bitand(self, rhs: MethodFlags) -> Self::Output {
        MethodFlags(self.0 & rhs.0)
    }
}

impl std::ops::BitAnd<MethodFlags> for &MethodFlags {
    type Output = MethodFlags;

    fn bitand(self, rhs: MethodFlags) -> Self::Output {
        MethodFlags(self.0 & rhs.0)
    }
}

impl std::ops::BitOr<MethodFlags> for MethodFlags {
    type Output = MethodFlags;

    fn bitor(self, rhs: MethodFlags) -> Self::Output {
        MethodFlags(self.0 | rhs.0)
    }
}

impl std::ops::BitOr<MethodFlags> for &MethodFlags {
    type Output = MethodFlags;

    fn bitor(self, rhs: MethodFlags) -> Self::Output {
        MethodFlags(self.0 | rhs.0)
    }
}

impl std::fmt::Debug for MethodFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "MethodFlags({})", self)
    }
}

impl std::fmt::Display for MethodFlags {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut first = true;
        for (flag, name) in Self::FLAGS {
            if self & flag == flag {
                if !first {
                    write!(f, " | {name}")?;
                } else {
                    write!(f, "{name}")?;
                    first = false;
                }
            }
        }
        Ok(())
    }
}

pub struct Code {
    pub max_stack: u16,
    pub max_locals: u16,
    pub bytecode: Vec<u8>,
}

impl Code {
    pub fn max_stack(&self) -> u16 {
        self.max_stack
    }

    pub fn max_locals(&self) -> u16 {
        self.max_locals
    }

    pub fn bytecode(&self) -> Bytecode {
        Bytecode::new(self.bytecode.as_slice())
    }
}

impl std::fmt::Debug for Code {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Code")
            .field("max_stack", &self.max_stack)
            .field("max_locals", &self.max_locals)
            .field("bytecode", &self.bytecode())
            .finish()
    }
}
